/*
* 潜水员为了潜水要使用特殊的装备。

他有一个带2种气体的气缸：一个为氧气，一个为氮气。

让潜水员下潜的深度需要各种数量的氧和氮。

潜水员有一定数量的气缸。

每个气缸都有重量和气体容量。

潜水员为了完成他的工作需要特定数量的氧和氮。

他完成工作所需气缸的总重的最低限度的是多少？

例如：潜水员有5个气缸。每行三个数字为：氧，氮的（升）量和气缸的重量：

    3 36 120
    
    10 25 129
    
    5 50 250
    
    1 45 130
    
    4 20 119
    

如果潜水员需要5升的氧和60升的氮则总重最小为249（1，2或者4，5号气缸）。

你的任务就是计算潜水员为了完成他的工作需要的气缸的重量的最低值。

#### 输入格式

第一行有2个整数 $m，n$。它们表示氧，氮各自需要的量。

第二行为整数 $k$ 表示气缸的个数。

此后的 $k$ 行，每行包括$a\_i，b\_i，c\_i$，3个整数。这些各自是：第 $i$ 个气缸里的氧和氮的容量及气缸重量。

#### 输出格式

仅一行包含一个整数，为潜水员完成工作所需的气缸的重量总和的最低值。

#### 数据范围

$1 \\le m \\le 21$,  
$1 \\le n \\le 79$,  
$1 \\le k \\le 1000$,  
$1 \\le a\_i \\le 21$,  
$1 \\le b\_i \\le 79$,  
$1 \\le c\_i \\le 800$

#### 输入样例：

    5 60
    5
    3 36 120
    10 25 129
    5 50 250
    1 45 130
    4 20 119
    

#### 输出样例：

    249
*/



/*
* 状态表示: 氧气最多是i，并且氢气最少是j的情况下，方案数最少是多少
*     属性：数量
* 状态方程：         f[i][j][k]
*           不选第i个物品，f[i-1][j][k]
*           选第i个物品，f[i][j-v][k-w] + w
* 最多是i，全部初始化为0
* 恰好是i，f[0][0]为0，其余为正无穷，j-v >= 0
* 最少是i，f[0][0]为0，其余为正无穷，j可以为0，小于时候意味最少为j，
* 所以可以为v，但是这里的v是大于j，所以可以看成只选v
*/

#include <iostream>
#include <cstring>
using namespace std;
const int N = 25, M = 85;
int f[N][M];
int m, n, k;
int main() {
    ios::sync_with_stdio(false);
    cin >> m >> n >> k;

    memset(f, 0x3f, sizeof f);
    f[0][0] = 0;

    for (int i = 0; i < k; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        for (int j = m; j >= 0; --j)
            for (int z = n; z >= 0; --z) 
                f[j][z] = min(f[j][z], f[max(0,j - a)][max(0,z - b)] + c);
    }
    cout << f[m][n] << endl;
	return 0;
}